package com.socialimpact.tracker.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.socialimpact.tracker.entity.*;
import com.socialimpact.tracker.entity.KpiReport.ReportStatus;
import com.socialimpact.tracker.repository.*;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

@Service
@RequiredArgsConstructor
@Slf4j
public class DartCollectorService {

    private final WebClient.Builder webClientBuilder;
    public final OrganizationRepository organizationRepository;
    public final ProjectRepository projectRepository;
    public final KpiRepository kpiRepository;
    public final KpiReportRepository kpiReportRepository;


    @Value("${opendart.api-key}")
    private String dartApiKey;

    @Value("${opendart.base-url}")
    private String dartBaseUrl;

    @Value("${ingest.donation.from-year}")
    private int fromYear;

    @Value("${ingest.donation.to-year}")
    private int toYear;

    @Value("${ingest.parallelism:4}")
    private int parallelism;

    @Getter
    private final AtomicInteger totalCompanies = new AtomicInteger(0);
    @Getter
    private final AtomicInteger processedCompanies = new AtomicInteger(0);
    @Getter
    private final AtomicInteger successCount = new AtomicInteger(0);
    @Getter
    private final AtomicInteger failureCount = new AtomicInteger(0);
    @Getter
    private volatile boolean isCollecting = false;
    @Getter
    private volatile long startTime = 0;

    public List<String> fetchAllCorpCodes() {
        log.info("üì• Fetching all corporation codes from DART...");
        log.info("üîë Using API Key: {}...", dartApiKey.substring(0, 10));

        try {
            WebClient webClient = webClientBuilder.baseUrl(dartBaseUrl).build();

            byte[] zipData = webClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path("/api/corpCode.xml")
                            .queryParam("crtfc_key", dartApiKey)
                            .build())
                    .retrieve()
                    .bodyToMono(byte[].class)
                    .block();

            if (zipData == null || zipData.length == 0) {
                log.error("‚ùå Received empty response from DART API");
                return new ArrayList<>();
            }

            log.info("üì¶ ZIP file size: {} bytes", zipData.length);

            if (zipData.length < 1000) {
                log.error("‚ùå ZIP file too small ({}bytes), might be an error response", zipData.length);
                log.error("Response: {}", new String(zipData, "UTF-8"));
                return new ArrayList<>();
            }

            String xmlContent = unzipCorpCode(zipData);
            List<String> corpCodes = parseCorpCodesFromXml(xmlContent);
            log.info("‚úÖ Successfully fetched {} corporation codes", corpCodes.size());

            return corpCodes;

        } catch (Exception e) {
            log.error("‚ùå Error fetching corp codes from DART", e);
            return new ArrayList<>();
        }
    }
    private String unzipCorpCode(byte[] zipData) throws Exception {
        log.info("üîì Unzipping... {} bytes", zipData.length);

        try (ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(zipData))) {
            ZipEntry entry;
            int entryCount = 0;

            while ((entry = zis.getNextEntry()) != null) {
                entryCount++;
                log.info("üìÑ Found entry #{}: {}", entryCount, entry.getName());

                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                byte[] buffer = new byte[1024];
                int len;
                while ((len = zis.read(buffer)) > 0) {
                    baos.write(buffer, 0, len);
                }

                String content = baos.toString("UTF-8");
                log.info("‚úÖ Extracted {} bytes from {}", content.length(), entry.getName());
                return content;
            }

            log.error("‚ùå No entries found in ZIP, entry count: {}", entryCount);
        }

        throw new Exception("No entry found in ZIP file");
    }

    private List<String> parseCorpCodesFromXml(String xml) {
        List<String> corpCodes = new ArrayList<>();

        try {
            XmlMapper xmlMapper = new XmlMapper();
            JsonNode root = xmlMapper.readTree(xml);
            JsonNode list = root.get("list");

            if (list != null && list.isArray()) {
                log.info("üìä Found {} items in array", list.size());

                for (JsonNode item : list) {
                    if (!item.has("corp_code")) continue;

                    String corpCode = item.get("corp_code").asText();
                    String stockCode = item.has("stock_code") ? item.get("stock_code").asText().trim() : "";

                    // ÏÉÅÏû•ÏÇ¨ ÌïÑÌÑ∞ÎßÅ: stock_codeÍ∞Ä ÏûàÍ≥† Ïà´ÏûêÎ°úÎßå Íµ¨ÏÑ±Îêú Í≤ΩÏö∞
                    if (!stockCode.isEmpty() && stockCode.matches("\\d{6}")) {
                        corpCodes.add(corpCode);
                    }
                }

                log.info("‚úÖ Total items: {}, Listed companies: {}", list.size(), corpCodes.size());
            }

        } catch (Exception e) {
            log.error("Error parsing XML", e);
        }

        return corpCodes;
    }

    @Transactional
    public void collectDonationData(String corpCode) {
        try {
            WebClient webClient = webClientBuilder.baseUrl(dartBaseUrl).build();

            String companyJson = webClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path("/api/company.json")
                            .queryParam("crtfc_key", dartApiKey)
                            .queryParam("corp_code", corpCode)
                            .build())
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();

            ObjectMapper mapper = new ObjectMapper();
            JsonNode companyInfo = mapper.readTree(companyJson);

            String status = companyInfo.path("status").asText();
            if (!"000".equals(status)) {
                failureCount.incrementAndGet();
                return;
            }

            String corpName = companyInfo.path("corp_name").asText();
            String stockCode = companyInfo.path("stock_code").asText();

            Organization org = saveOrUpdateOrganization(corpName, stockCode);

            boolean hasData = false;
            for (int year = fromYear; year <= toYear; year++) {
                if (collectDonationForYear(webClient, mapper, corpCode, org, year)) {
                    hasData = true;
                }
            }

            if (hasData) {
                successCount.incrementAndGet();
            } else {
                failureCount.incrementAndGet();
            }

        } catch (WebClientResponseException.TooManyRequests e) {
            log.warn("‚ö†Ô∏è  Rate limit hit for corp: {}, will retry", corpCode);
            try {
                Thread.sleep(5000);
                collectDonationData(corpCode);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
                failureCount.incrementAndGet();
            }
        } catch (Exception e) {
            failureCount.incrementAndGet();
        } finally {
            processedCompanies.incrementAndGet();
        }
    }

    private boolean collectDonationForYear(WebClient webClient, ObjectMapper mapper,
                                           String corpCode, Organization org, int year) {
        try {
            // ‚≠ê Ïó∞ÎèÑÎ≥Ñ Í≥µÏãú Í≤ÄÏÉâ (Ï†úÏ∂úÏùº Í∏∞Ï§Ä)
            // 2024ÎÖÑ = 2024ÎÖÑ 1Ïõî ~ 12ÏõîÏóê Ï†úÏ∂úÎêú Í≥µÏãú
            String bgnDe = year + "0101";
            String endDe = year + "1231";

            String listJson = webClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path("/api/list.json")
                            .queryParam("crtfc_key", dartApiKey)
                            .queryParam("corp_code", corpCode)
                            .queryParam("bgn_de", bgnDe)
                            .queryParam("end_de", endDe)
                            .queryParam("pblntf_ty", "A")
                            .build())
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();

            JsonNode listRoot = mapper.readTree(listJson);
            JsonNode reports = listRoot.path("list");

            if (!reports.isArray() || reports.size() == 0) {
                log.debug("‚ùå No reports found for {} in {}", corpCode, year);
                return false;
            }

            log.debug("üìä Found {} reports for year {}", reports.size(), year);

            for (JsonNode report : reports) {
                String reportNm = report.path("report_nm").asText();

                // ‚≠ê ÏÇ¨ÏóÖÎ≥¥Í≥†ÏÑúÎßå Ï≤òÎ¶¨
                if (reportNm.contains("ÏÇ¨ÏóÖÎ≥¥Í≥†ÏÑú")) {
                    String rceptNo = report.path("rcept_no").asText();
                    String rceptDt = report.path("rcept_dt").asText();

                    log.debug("üìÑ Processing report: {} (Ï†ëÏàòÏùº: {})", reportNm, rceptDt);

                    BigDecimal donationAmount = extractDonationAmountFromReport(webClient, rceptNo);

                    if (donationAmount != null && donationAmount.compareTo(BigDecimal.ZERO) > 0) {
                        // ‚≠ê ÏÇ¨ÏóÖÎ≥¥Í≥†ÏÑúÏùò 'ÏÇ¨ÏóÖÏó∞ÎèÑ'Î•º Ï∂îÏ∂ú (Ïòà: "ÏÇ¨ÏóÖÎ≥¥Í≥†ÏÑú (2023.12)" ‚Üí 2023)
                        int businessYear = year - 1; // ÏùºÎ∞òÏ†ÅÏúºÎ°ú Ï†ÑÎÖÑÎèÑ Îç∞Ïù¥ÌÑ∞

                        // Î≥¥Í≥†ÏÑúÎ™ÖÏóêÏÑú Ïó∞ÎèÑ Ï∂îÏ∂ú ÏãúÎèÑ
                        if (reportNm.matches(".*\\((\\d{4})\\..*")) {
                            String yearStr = reportNm.replaceAll(".*\\((\\d{4})\\..*", "$1");
                            businessYear = Integer.parseInt(yearStr);
                        }

                        log.info("‚úÖ {} (ÏÇ¨ÏóÖÏó∞ÎèÑ: {}): {} Ïõê",
                                org.getName(), businessYear, donationAmount);

                        saveKpiReport(org, donationAmount, businessYear);
                        return true;
                    }
                }
            }

            return false;

        } catch (Exception e) {
            log.error("‚ùå Error collecting data for {} year {}: {}", corpCode, year, e.getMessage());
            return false;
        }
    }


    private BigDecimal extractDonationAmountFromReport(WebClient webClient, String rceptNo) {
        try {
            log.info("üìÑ Fetching report document: {}", rceptNo);

            String documentHtml = webClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path("/api/document.xml")
                            .queryParam("crtfc_key", dartApiKey)
                            .queryParam("rcept_no", rceptNo)
                            .build())
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();

            if (documentHtml == null || documentHtml.isEmpty()) {
                log.warn("‚ùå Empty document for {}", rceptNo);
                return null;
            }

            log.info("üìÑ Document size: {} bytes", documentHtml.length());

            // ‚≠ê "Í∏∞Î∂ÄÍ∏à" ÌÖçÏä§Ìä∏ Ìè¨Ìï® Ïó¨Î∂Ä ÌôïÏù∏
            if (documentHtml.contains("Í∏∞Î∂ÄÍ∏à")) {
                log.info("‚úÖ Document contains 'Í∏∞Î∂ÄÍ∏à' keyword");

                // "Í∏∞Î∂ÄÍ∏à" Í∑ºÏ≤ò ÌÖçÏä§Ìä∏ Ï∂úÎ†•
                int idx = documentHtml.indexOf("Í∏∞Î∂ÄÍ∏à");
                int start = Math.max(0, idx - 300);
                int end = Math.min(documentHtml.length(), idx + 500);
                String context = documentHtml.substring(start, end);

                log.info("üìù Context around 'Í∏∞Î∂ÄÍ∏à':\n{}", context);
            } else {
                log.warn("‚ùå Document does NOT contain 'Í∏∞Î∂ÄÍ∏à' keyword");
            }

            // ‚≠ê JsoupÏúºÎ°ú HTML ÌååÏã±
            Document doc = Jsoup.parse(documentHtml);

            // Î™®Îì† ÌÖåÏù¥Î∏î Ï∞æÍ∏∞
            Elements tables = doc.select("table");
            log.info("üìä Found {} tables in document", tables.size());

            int tableIndex = 0;
            for (Element table : tables) {
                tableIndex++;

                Elements rows = table.select("tr");

                for (int rowIndex = 0; rowIndex < rows.size(); rowIndex++) {
                    Element row = rows.get(rowIndex);
                    Elements cells = row.select("td, th");

                    if (cells.size() >= 2) {
                        String firstCell = cells.get(0).text().trim();
                        String secondCell = cells.get(1).text().trim();

                        // "Í∏∞Î∂Ä" ÌÇ§ÏõåÎìú Ìè¨Ìï®Îêú Ìñâ Î™®Îëê Ï∂úÎ†•
                        if (firstCell.contains("Í∏∞Î∂Ä") || firstCell.contains("ÏÇ¨ÌöåÍ≥µÌóå")) {
                            log.info("üîç Table #{}, Row #{}: '{}' = '{}'",
                                    tableIndex, rowIndex, firstCell, secondCell);

                            // Ïà´Ïûê Ï∂îÏ∂ú ÏãúÎèÑ
                            String numericValue = secondCell.replaceAll("[^0-9]", "");

                            if (!numericValue.isEmpty() && numericValue.length() >= 3) {
                                try {
                                    BigDecimal amount = new BigDecimal(numericValue);

                                    // Î∞±ÎßåÏõê Îã®ÏúÑÎ°ú Î≥ÄÌôò
                                    BigDecimal actualAmount = amount.multiply(BigDecimal.valueOf(1_000_000));

                                    log.info("üí∞ Extracted number: {} ‚Üí {} Î∞±ÎßåÏõê ‚Üí {} Ïõê",
                                            secondCell, amount, actualAmount);

                                    // 1Î∞±ÎßåÏõê ~ 100Ï°∞Ïõê ÏÇ¨Ïù¥Î©¥ Ïú†Ìö®
                                    if (actualAmount.compareTo(BigDecimal.valueOf(1_000_000L)) >= 0 &&
                                            actualAmount.compareTo(BigDecimal.valueOf(100_000_000_000_000L)) <= 0) {

                                        log.info("‚úÖ VALID donation amount found!");
                                        return actualAmount;
                                    }
                                } catch (NumberFormatException e) {
                                    log.debug("‚è≠Ô∏è  Number format error: {}", numericValue);
                                }
                            }
                        }
                    }
                }
            }

            log.info("‚ùå No 'Í∏∞Î∂ÄÍ∏à' data found in report {}", rceptNo);
            return null;

        } catch (Exception e) {
            log.error("‚ùå Error extracting donation", e);
            return null;
        }
    }


    private Organization saveOrUpdateOrganization(String corpName, String stockCode) {
        return organizationRepository.findAll().stream()
                .filter(o -> o.getName().equals(corpName))
                .findFirst()
                .orElseGet(() -> {
                    Organization org = new Organization();
                    org.setName(corpName);
                    org.setType("ÏÉÅÏû•ÏÇ¨");
                    return organizationRepository.save(org);
                });
    }

    private void saveKpiReport(Organization org, BigDecimal amount, int year) {
        String projectName = org.getName() + " CSR " + year;
        Project project = projectRepository.findAll().stream()
                .filter(p -> p.getName().equals(projectName))
                .findFirst()
                .orElseGet(() -> {
                    Project p = new Project();
                    p.setOrganization(org);
                    p.setName(projectName);
                    p.setCategory("CSR");
                    p.setStartDate(LocalDate.of(year, 1, 1));
                    return projectRepository.save(p);
                });

        Kpi donationKpi = kpiRepository.findByName("Donation Amount")
                .orElseGet(() -> {
                    Kpi kpi = new Kpi();
                    kpi.setName("Donation Amount");
                    kpi.setUnit("Ïõê");
                    kpi.setCategory("Finance");
                    return kpiRepository.save(kpi);
                });

        KpiReport report = new KpiReport();
        report.setProject(project);
        report.setKpi(donationKpi);
        report.setValue(amount);
        report.setReportDate(LocalDate.of(year, 12, 31));
        report.setStatus(ReportStatus.APPROVED);
        report.setApprovedBy("DART_AUTO");

        kpiReportRepository.save(report);
    }

    public void collectAllListedCompanies() {
        if (isCollecting) {
            log.warn("‚ö†Ô∏è  Data collection is already in progress!");
            return;
        }

        isCollecting = true;
        startTime = System.currentTimeMillis();
        processedCompanies.set(0);
        successCount.set(0);
        failureCount.set(0);

        log.info("üöÄ Starting parallel data collection...");
        log.info("‚öôÔ∏è  Parallelism: {} threads", parallelism);

        List<String> corpCodes = fetchAllCorpCodes();

        // ‚≠ê‚≠ê‚≠ê Ïó¨Í∏∞Ïóê Ï∂îÍ∞Ä ‚≠ê‚≠ê‚≠ê
        int SKIP_COUNT = 1615;
        if (corpCodes.size() > SKIP_COUNT) {
            log.info("‚è© Skipping first {} companies (already processed)", SKIP_COUNT);
            corpCodes = corpCodes.subList(SKIP_COUNT, corpCodes.size());
        }
        // ‚≠ê‚≠ê‚≠ê Ïó¨Í∏∞ÍπåÏßÄ ‚≠ê‚≠ê‚≠ê

        totalCompanies.set(corpCodes.size());

        log.info("üìä Total companies to process: {}", totalCompanies.get());

        ExecutorService executor = Executors.newFixedThreadPool(parallelism);
        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (String corpCode : corpCodes) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    collectDonationData(corpCode);
                    Thread.sleep(250);
                } catch (Exception e) {
                    log.error("Error processing corp: {}", corpCode, e);
                }
            }, executor);

            futures.add(future);
        }

        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenRun(() -> {
                    long duration = (System.currentTimeMillis() - startTime) / 1000;
                    log.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                    log.info("‚úÖ Data Collection Completed!");
                    log.info("üìä Total: {} | Success: {} | Failed: {}",
                            totalCompanies.get(), successCount.get(), failureCount.get());
                    log.info("‚è±Ô∏è  Total time: {} seconds ({} minutes)", duration, duration / 60);
                    log.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                    isCollecting = false;
                    executor.shutdown();
                })
                .join();
    }

    public double getProgressPercentage() {
        if (totalCompanies.get() == 0) return 0.0;
        return (processedCompanies.get() * 100.0) / totalCompanies.get();
    }

    public long getEstimatedTimeRemaining() {
        if (!isCollecting || processedCompanies.get() == 0) return 0;

        long elapsed = System.currentTimeMillis() - startTime;
        int remaining = totalCompanies.get() - processedCompanies.get();
        long avgTimePerCompany = elapsed / processedCompanies.get();

        return (avgTimePerCompany * remaining) / 1000;
    }
}